/*Copyright (c) 2016-2017 wavemaker.com All Rights Reserved.
 This software is the confidential and proprietary information of wavemaker.com You shall not disclose such Confidential Information and shall use it only in accordance
 with the terms of the source code license agreement you entered into with wavemaker.com*/

package com.javaserviceautowiring.dbscenarios.service;

/*This is a Studio Managed File. DO NOT EDIT THIS FILE. Your changes may be reverted by Studio.*/

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.wavemaker.runtime.data.dao.query.WMQueryExecutor;
import com.wavemaker.runtime.data.exception.BlobContentNotFoundException;
import com.wavemaker.runtime.data.exception.EntityNotFoundException;
import com.wavemaker.runtime.data.export.ExportType;
import com.wavemaker.runtime.file.model.Downloadable;

import com.javaserviceautowiring.dbscenarios.models.query.*;

@Service
public class DbscenariosQueryExecutorServiceImpl implements DbscenariosQueryExecutorService {

    private static final Logger LOGGER = LoggerFactory.getLogger(DbscenariosQueryExecutorServiceImpl.class);

    @Autowired
    @Qualifier("dbscenariosWMQueryExecutor")
    private WMQueryExecutor queryExecutor;

    @Transactional(value = "dbscenariosTransactionManager")
    @Override
    public Integer executeSV_InsertWithBlob(SvInsertWithBlobRequest svInsertWithBlobRequest) {
        Map params = new HashMap(18);

        params.put("BYTECOL", svInsertWithBlobRequest.getBytecol());
        params.put("SHORTCOL", svInsertWithBlobRequest.getShortcol());
        params.put("INTCOL", svInsertWithBlobRequest.getIntcol());
        params.put("FLOATCOL", svInsertWithBlobRequest.getFloatcol());
        params.put("LONGCOL", svInsertWithBlobRequest.getLongcol());
        params.put("DOUBLECOL", svInsertWithBlobRequest.getDoublecol());
        params.put("BIGINTCOL", svInsertWithBlobRequest.getBigintcol());
        params.put("BIGDECCOL", svInsertWithBlobRequest.getBigdeccol());
        params.put("CHARCOL", svInsertWithBlobRequest.getCharcol());
        params.put("STRINGCOL", svInsertWithBlobRequest.getStringcol());
        params.put("TEXTCOL", svInsertWithBlobRequest.getTextcol());
        params.put("CLOBCOL", svInsertWithBlobRequest.getClobcol());
        params.put("DATECOL", svInsertWithBlobRequest.getDatecol());
        params.put("TIMECOL", svInsertWithBlobRequest.getTimecol());
        params.put("DATETIMECOL", svInsertWithBlobRequest.getDatetimecol());
        params.put("TIMESTAMPCOL", svInsertWithBlobRequest.getTimestampcol());
        params.put("BOOLEANCOL", svInsertWithBlobRequest.getBooleancol());
        params.put("BLOBCOL", svInsertWithBlobRequest.getBlobcol());

        return queryExecutor.executeNamedQueryForUpdate("SV_InsertWithBlob", params);
    }

    @Transactional(readOnly = true, value = "dbscenariosTransactionManager")
    @Override
    public Page<SvGetAllTypesResponse> executeSV_GetAllTypes(Pageable pageable) {
        Map params = new HashMap(0);


        return queryExecutor.executeNamedQuery("SV_GetAllTypes", params, SvGetAllTypesResponse.class, pageable);
    }

    @Transactional(readOnly = true, value = "dbscenariosTransactionManager")
    @Override
    public InputStream getBlobColContentForSV_GetAllTypes(Integer pkId) throws EntityNotFoundException {
        Map params = new HashMap(0);

        params.put("pkId", pkId);

        SvGetAllTypesResponse _result =  queryExecutor.executeNamedQuery("SV_GetAllTypes__identifier", params, SvGetAllTypesResponse.class);
        if(_result.getBlobCol() == null) {
            LOGGER.debug("Blob content not exists for blobCol in query SV_GetAllTypes");
            throw new BlobContentNotFoundException("Blob content not found for blobCol in query SV_GetAllTypes");
        }
        return new ByteArrayInputStream(_result.getBlobCol());
    }

    @Transactional(readOnly = true, value = "dbscenariosTransactionManager")
    @Override
    public Downloadable exportSV_GetAllTypes(ExportType exportType, Pageable pageable) {
        Map params = new HashMap(0);


        return queryExecutor.exportNamedQueryData("SV_GetAllTypes", params, exportType, SvGetAllTypesResponse.class, pageable);
    }

    @Transactional(readOnly = true, value = "dbscenariosTransactionManager")
    @Override
    public SvGetAllTypesSingleResponse executeSV_GetAllTypesSingle() {
        Map params = new HashMap(0);


        return queryExecutor.executeNamedQuery("SV_GetAllTypesSingle", params, SvGetAllTypesSingleResponse.class);
    }

    @Transactional(readOnly = true, value = "dbscenariosTransactionManager")
    @Override
    public InputStream getBlobColContentForSV_GetAllTypesSingle() throws EntityNotFoundException {
        Map params = new HashMap(0);


        SvGetAllTypesSingleResponse _result =  queryExecutor.executeNamedQuery("SV_GetAllTypesSingle", params, SvGetAllTypesSingleResponse.class);
        if(_result.getBlobCol() == null) {
            LOGGER.debug("Blob content not exists for blobCol in query SV_GetAllTypesSingle");
            throw new BlobContentNotFoundException("Blob content not found for blobCol in query SV_GetAllTypesSingle");
        }
        return new ByteArrayInputStream(_result.getBlobCol());
    }

    @Transactional(readOnly = true, value = "dbscenariosTransactionManager")
    @Override
    public SvGetLoggedInIdByPkIdResponse executeSV_GetLoggedInIdByPkId() {
        Map params = new HashMap(0);


        return queryExecutor.executeNamedQuery("SV_GetLoggedInIdByPkId", params, SvGetLoggedInIdByPkIdResponse.class);
    }

    @Transactional(readOnly = true, value = "dbscenariosTransactionManager")
    @Override
    public InputStream getBlobColContentForSV_GetLoggedInIdByPkId() throws EntityNotFoundException {
        Map params = new HashMap(0);


        SvGetLoggedInIdByPkIdResponse _result =  queryExecutor.executeNamedQuery("SV_GetLoggedInIdByPkId", params, SvGetLoggedInIdByPkIdResponse.class);
        if(_result.getBlobCol() == null) {
            LOGGER.debug("Blob content not exists for blobCol in query SV_GetLoggedInIdByPkId");
            throw new BlobContentNotFoundException("Blob content not found for blobCol in query SV_GetLoggedInIdByPkId");
        }
        return new ByteArrayInputStream(_result.getBlobCol());
    }

    @Transactional(value = "dbscenariosTransactionManager")
    @Override
    public Integer executeSV_InsertQuery(SvInsertQueryRequest svInsertQueryRequest) {
        Map params = new HashMap(17);

        params.put("BYTECOL", svInsertQueryRequest.getBytecol());
        params.put("SHORTCOL", svInsertQueryRequest.getShortcol());
        params.put("INTCOL", svInsertQueryRequest.getIntcol());
        params.put("FLOATCOL", svInsertQueryRequest.getFloatcol());
        params.put("LONGCOL", svInsertQueryRequest.getLongcol());
        params.put("DOUBLECOL", svInsertQueryRequest.getDoublecol());
        params.put("BIGINTCOL", svInsertQueryRequest.getBigintcol());
        params.put("BIGDECCOL", svInsertQueryRequest.getBigdeccol());
        params.put("CHARCOL", svInsertQueryRequest.getCharcol());
        params.put("STRINGCOL", svInsertQueryRequest.getStringcol());
        params.put("TEXTCOL", svInsertQueryRequest.getTextcol());
        params.put("CLOBCOL", svInsertQueryRequest.getClobcol());
        params.put("DATECOL", svInsertQueryRequest.getDatecol());
        params.put("TIMECOL", svInsertQueryRequest.getTimecol());
        params.put("DATETIMECOL", svInsertQueryRequest.getDatetimecol());
        params.put("TIMESTAMPCOL", svInsertQueryRequest.getTimestampcol());
        params.put("BOOLEANCOL", svInsertQueryRequest.getBooleancol());

        return queryExecutor.executeNamedQueryForUpdate("SV_InsertQuery", params);
    }

    @Transactional(readOnly = true, value = "dbscenariosTransactionManager")
    @Override
    public Page<SvAllTypesWithoutSpaceResponse> executeSV_AllTypesWithoutSpace(Pageable pageable) {
        Map params = new HashMap(0);


        return queryExecutor.executeNamedQuery("SV_AllTypesWithoutSpace", params, SvAllTypesWithoutSpaceResponse.class, pageable);
    }

    @Transactional(readOnly = true, value = "dbscenariosTransactionManager")
    @Override
    public InputStream getBlobcolContentForSV_AllTypesWithoutSpace(Integer pkid) throws EntityNotFoundException {
        Map params = new HashMap(0);

        params.put("pkid", pkid);

        SvAllTypesWithoutSpaceResponse _result =  queryExecutor.executeNamedQuery("SV_AllTypesWithoutSpace__identifier", params, SvAllTypesWithoutSpaceResponse.class);
        if(_result.getBlobcol() == null) {
            LOGGER.debug("Blob content not exists for blobcol in query SV_AllTypesWithoutSpace");
            throw new BlobContentNotFoundException("Blob content not found for blobcol in query SV_AllTypesWithoutSpace");
        }
        return new ByteArrayInputStream(_result.getBlobcol());
    }

    @Transactional(readOnly = true, value = "dbscenariosTransactionManager")
    @Override
    public Downloadable exportSV_AllTypesWithoutSpace(ExportType exportType, Pageable pageable) {
        Map params = new HashMap(0);


        return queryExecutor.exportNamedQueryData("SV_AllTypesWithoutSpace", params, exportType, SvAllTypesWithoutSpaceResponse.class, pageable);
    }

    @Transactional(readOnly = true, value = "dbscenariosTransactionManager")
    @Override
    public Page<SvGetByLoggedInIdResponse> executeSV_GetByLoggedInId(Pageable pageable) {
        Map params = new HashMap(0);


        return queryExecutor.executeNamedQuery("SV_GetByLoggedInId", params, SvGetByLoggedInIdResponse.class, pageable);
    }

    @Transactional(readOnly = true, value = "dbscenariosTransactionManager")
    @Override
    public InputStream getBlobColContentForSV_GetByLoggedInId() throws EntityNotFoundException {
        Map params = new HashMap(0);


        SvGetByLoggedInIdResponse _result =  queryExecutor.executeNamedQuery("SV_GetByLoggedInId", params, SvGetByLoggedInIdResponse.class);
        if(_result.getBlobCol() == null) {
            LOGGER.debug("Blob content not exists for blobCol in query SV_GetByLoggedInId");
            throw new BlobContentNotFoundException("Blob content not found for blobCol in query SV_GetByLoggedInId");
        }
        return new ByteArrayInputStream(_result.getBlobCol());
    }

    @Transactional(readOnly = true, value = "dbscenariosTransactionManager")
    @Override
    public Downloadable exportSV_GetByLoggedInId(ExportType exportType, Pageable pageable) {
        Map params = new HashMap(0);


        return queryExecutor.exportNamedQueryData("SV_GetByLoggedInId", params, exportType, SvGetByLoggedInIdResponse.class, pageable);
    }

}


